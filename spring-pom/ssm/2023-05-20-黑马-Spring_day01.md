---
type: basic-note
title: Spring-day01
author: JackyLee
create_date: 2023-05-20
update_date:
tags:
description: 黑马程序员
---

## 1 主要内容

特性： IOC AOP(处理事务)

框架整合:

- MyBatis
- MyBatis-plus
- Struts
- Struts2
- Hibernate
- ……

## 2 Spring 相关概念

#### 2.1.1 Spring 家族

- [Spring | Home](https://spring.io/)

  - web 开发、微服务、分布式系统
  - Spring 全家桶: 查看官网 project 查看所有技术

    - 关注 `Spring Framework`、`SpringBoot`和`SpringCloud`:
    - Spring Framework:Spring 框架，是 Spring 中最早最核心的技术，也是所有其他技术的基础。
    - SpringBoot:Spring 是来简化开发，而 SpringBoot 是来帮助 Spring 在简化的基础上能更快速进行开发。
    - SpringCloud:这个是用来做分布式之微服务架构的相关开发。

    - 其他的比如也比较流行，如 SpringData,SpringSecurity 等

#### 2.1.2 了解 Spring 发展史

接下来我们介绍下 Spring Framework 这个技术是如何来的呢?

![image-20210729171926576](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151020916.png)

Spring 发展史

- IBM(IT 公司-国际商业机器公司)在 1997 年提出了 EJB 思想,早期的 JAVAEE 开发大都基于该思想。
- Rod Johnson(Java 和 J2EE 开发领域的专家)在 2002 年出版的`Expert One-on-One J2EE Design and Development`,书中有阐述在开发中使用 EJB 该如何做。
- Rod Johnson 在 2004 年出版的`Expert One-on-One J2EE Development without EJB`,书中提出了比 EJB 思想更高效的实现方案，并且在同年将方案进行了具体的落地实现，这个实现就是 Spring1.0。
- 随着时间推移，版本不断更新维护，目前最新的是 Spring5
  - Spring1.0 是纯配置文件开发
  - Spring2.0 为了简化开发引入了注解开发，此时是配置文件加注解的开发方式
  - Spring3.0 已经可以进行纯注解开发，使开发效率大幅提升，我们的课程会以注解开发为主
  - Spring4.0 根据 JDK 的版本升级对个别 API 进行了调整
  - Spring5.0 已经全面支持 JDK8，现在 Spring 最新的是 5 系列所以建议大家把 JDK 安装成 1.8 版

### 2.2 Spring 系统架构

前面我们说 spring 指的是 Spring Framework,那么它其中都包含哪些内容以及我们该如何学习这个框架?

针对这些问题，我们将从`系统架构图`和`课程学习路线`来进行说明:

#### 2.2.1 系统架构图

![image-20210729172153796](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151020917.png)

Spring Framework 的 5 版本目前没有最新的架构图，而最新的是 4 版本，所以接下来主要研究的是 4 的架构图

![1629720945720](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151020918.png)

1. 核心层
   - Core Container:核心容器，这个模块是 Spring 最核心的模块，其他的都需要依赖该模块
2. AOP 层
   - AOP:面向切面编程，它依赖核心层容器，目的是==在不改变原有代码的前提下对其进行功能增强==
   - Aspects:AOP 是思想,Aspects 是对 AOP 思想的具体实现
3. 数据层
   - Data Access:数据访问，Spring 全家桶中有对数据访问的具体实现技术
   - Data Integration:数据集成，Spring 支持整合其他的数据层解决方案，比如 Mybatis
   - Transactions:事务，Spring 中事务管理是 Spring AOP 的一个具体实现，也是后期学习的重点内容
4. Web 层
   - 这一层的内容将在 SpringMVC 框架具体学习
5. Test 层
   - Spring 主要整合了 Junit 来完成单元测试和集成测试

#### 2.2.2 学习路线

介绍完 Spring 的体系结构后，从中我们可以得出对于 Spring 的学习主要包含四部分内容，分别是:

- IOC / DI
- AOP
- AOP 的具体应用,事务管理
- IOC/DI 的具体应用,整合 Mybatis

## 2.3 Spring 核心概念

### 2.3.2 IOC、IOC 容器、Bean、DI

1. ==IOC（Inversion of Control）控制反转==

(1)什么是控制反转呢？

- 使用对象时，由主动 new 产生对象转换为由==外部==提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。
  - 业务层要用数据层的类对象，以前是自己`new`的
  - 现在自己不 new 了，交给`别人[外部]`来创建对象
  - `别人[外部]`就反转控制了数据层对象的创建权
  - 这种思想就是控制反转
  - 别人[外部]指定是什么呢?继续往下学

(2)Spring 和 IOC 之间的关系是什么呢?

- Spring 技术对 IOC 思想进行了实现
- Spring 提供了一个容器，称为==IOC 容器==，用来充当 IOC 思想中的"外部"
- IOC 思想中的`别人[外部]`指的就是 Spring 的 IOC 容器

(3)IOC 容器的作用以及内部存放的是什么?

- IOC 容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象
- 被创建或被管理的对象在 IOC 容器中统称为==Bean==
- IOC 容器中放的就是一个个的 Bean 对象

(4)当 IOC 容器中创建好 service 和 dao 对象后，程序能正确执行么?

- 不行，因为 service 运行需要依赖 dao 对象
- IOC 容器中虽然有 service 和 dao 对象
- 但是 service 对象和 dao 对象没有任何关系
- 需要把 dao 对象交给 service,也就是说要绑定 service 和 dao 对象之间的关系

像这种在容器中建立对象与对象之间的绑定关系就要用到 DI:

2. ==DI（Dependency Injection）依赖注入==

![1629735078619](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151020922.png)

(1)什么是依赖注入呢?

- 在容器中建立 bean 与 bean 之间的依赖关系的整个过程，称为依赖注入
  - 业务层要用数据层的类对象，以前是自己`new`的
  - 现在自己不 new 了，靠`别人[外部其实指的就是IOC容器]`来给注入进来
  - 这种思想就是依赖注入

(2)IOC 容器中哪些 bean 之间要建立依赖关系呢?

- 这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service 就要和 dao 建立依赖关系

介绍完 Spring 的 IOC 和 DI 的概念后，我们会发现这两个概念的最终目标就是:==充分解耦==，具体实现靠:

- 使用 IOC 容器管理 bean（IOC)
- 在 IOC 容器内将有依赖关系的 bean 进行关系绑定（DI）
- 最终结果为:使用对象时不仅可以直接从 IOC 容器中获取，并且获取到的 bean 已经绑定了所有的依赖关系.

#### 2.3.3 核心概念小结

这节比较重要，重点要理解`什么是IOC/DI思想`、`什么是IOC容器`和`什么是Bean`：

(1)什么 IOC/DI 思想?

- IOC:控制反转，控制反转的是对象的创建权
- DI:依赖注入，绑定对象与对象之间的依赖关系

(2)什么是 IOC 容器?

Spring 创建了一个容器用来存放所创建的对象，这个容器就叫 IOC 容器

(3)什么是 Bean?

容器中所存放的一个个对象就叫 Bean 或 Bean 对象

## 5 DI 相关内容

前面我们已经完成了 bean 相关操作的讲解，接下来就进入第二个大的模块`DI依赖注入`，首先来介绍下 Spring 中有哪些注入方式?

我们先来思考

- 向一个类中传递数据的方式有几种?
  - 普通方法(set 方法)
  - 构造方法
- 依赖注入描述了在容器中建立 bean 与 bean 之间的依赖关系的过程，如果 bean 运行需要的是数字或字符串呢?
  - 引用类型
  - 简单类型(基本数据类型与 String)

Spring 就是基于上面这些知识点，为我们提供了两种注入方式，分别是:

- setter 注入
  - 简单类型
  - ==引用类型==
- 构造器注入
  - 简单类型
  - 引用类型

#### 5.1.3 注入简单数据类型

> 需求：给 BookDaoImpl 注入一些简单数据类型的数据
>
> 参考引用数据类型的注入，我们可以推出具体的步骤为:
>
> 1.在 BookDaoImpl 类中声明对应的简单数据类型的属性
>
> 2.为这些属性提供对应的 setter 方法
>
> 3.在 applicationContext.xml 中配置

**思考:**

引用类型使用的是`<property name="" ref=""/>`,简单数据类型还是使用 ref 么?

ref 是指向 Spring 的 IOC 容器中的另一个 bean 对象的，对于简单数据类型，没有对应的 bean 对象，该如何配置?

##### 步骤 1:声明属性并提供 setter 方法

在 BookDaoImpl 类中声明对应的简单数据类型的属性,并提供对应的 setter 方法

```java
public class BookDaoImpl implements BookDao {

    private String databaseName;
    private int connectionNum;

    public void setConnectionNum(int connectionNum) {
        this.connectionNum = connectionNum;
    }

    public void setDatabaseName(String databaseName) {
        this.databaseName = databaseName;
    }

    public void save() {
        System.out.println("book dao save ..."+databaseName+","+connectionNum);
    }
}
```

##### 步骤 2:配置文件中进行注入配置

在 applicationContext.xml 配置文件中使用 property 标签注入

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl">
        <property name="databaseName" value="mysql"/>
     	<property name="connectionNum" value="10"/>
    </bean>
    <bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"/>
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl">
        <property name="bookDao" ref="bookDao"/>
        <property name="userDao" ref="userDao"/>
    </bean>
</beans>
```

**说明:**

value:后面跟的是简单数据类型，对于参数类型，Spring 在注入的时候会自动转换，但是不能写成

```xml
<property name="connectionNum" value="abc"/>
```

这样的话，spring 在将`abc`转换成 int 类型的时候就会报错。

##### 步骤 3:运行程序

运行 AppForDISet 类，查看结果，说明 userDao 已经成功注入。

![1629800324721](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151020955.png)

**注意:**两个 property 注入标签的顺序可以任意。

对于 setter 注入方式的基本使用就已经介绍完了，

- 对于引用数据类型使用的是`<property name="" ref=""/>`
- 对于简单数据类型使用的是`<property name="" value=""/>`

### 5.2 构造器注入

#### 5.2.1 环境准备

构造器注入也就是构造方法注入，学习之前，还是先准备下环境:

- 创建一个 Maven 项目
- pom.xml 添加依赖
- resources 下添加 spring 的配置文件

这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:

![1629800748639](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151020956.png)

(1)项目中添加 BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService 和 BookServiceImpl 类

```java
public interface BookDao {
    public void save();
}

public class BookDaoImpl implements BookDao {

    private String databaseName;
    private int connectionNum;

    public void save() {
        System.out.println("book dao save ...");
    }
}
public interface UserDao {
    public void save();
}
public class UserDaoImpl implements UserDao {
    public void save() {
        System.out.println("user dao save ...");
    }
}

public interface BookService {
    public void save();
}

public class BookServiceImpl implements BookService{
    private BookDao bookDao;

    public void setBookDao(BookDao bookDao) {
        this.bookDao = bookDao;
    }

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}
```

(2)resources 下提供 spring 的配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl">
        <property name="bookDao" ref="bookDao"/>
    </bean>
</beans>
```

(3)编写 AppForDIConstructor 运行类，加载 Spring 的 IOC 容器，并从中获取对应的 bean 对象

```java
public class AppForDIConstructor {
    public static void main( String[] args ) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        BookService bookService = (BookService) ctx.getBean("bookService");
        bookService.save();
    }
}
```

#### 5.2.2 构造器注入引用数据类型

接下来，在上面这个环境中来完成构造器注入的学习:

> 需求：将 BookServiceImpl 类中的 bookDao 修改成使用构造器的方式注入。
>
> 1.将 bookDao 的 setter 方法删除掉
>
> 2.添加带有 bookDao 参数的构造方法
>
> 3.在 applicationContext.xml 中配置

##### 步骤 1:删除 setter 方法并提供构造方法

在 BookServiceImpl 类中将 bookDao 的 setter 方法删除掉,并添加带有 bookDao 参数的构造方法

```java
public class BookServiceImpl implements BookService{
    private BookDao bookDao;

    public BookServiceImpl(BookDao bookDao) {
        this.bookDao = bookDao;
    }

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}
```

##### 步骤 2:配置文件中进行配置构造方式注入

在 applicationContext.xml 中配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl">
        <constructor-arg name="bookDao" ref="bookDao"/>
    </bean>
</beans>
```

**说明:**

标签<constructor-arg>中

- name 属性对应的值为构造函数中方法形参的参数名，必须要保持一致。

- ref 属性指向的是 spring 的 IOC 容器中其他 bean 对象。

##### 步骤 3：运行程序

运行 AppForDIConstructor 类，查看结果，说明 bookDao 已经成功注入。

![1629802656916](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151020957.png)

#### 5.2.3 构造器注入多个引用数据类型

> 需求:在 BookServiceImpl 使用构造函数注入多个引用数据类型，比如 userDao
>
> 1.声明 userDao 属性
>
> 2.生成一个带有 bookDao 和 userDao 参数的构造函数
>
> 3.在 applicationContext.xml 中配置注入

##### 步骤 1:提供多个属性的构造函数

在 BookServiceImpl 声明 userDao 并提供多个参数的构造函数

```java
public class BookServiceImpl implements BookService{
    private BookDao bookDao;
    private UserDao userDao;

    public BookServiceImpl(BookDao bookDao,UserDao userDao) {
        this.bookDao = bookDao;
        this.userDao = userDao;
    }

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
        userDao.save();
    }
}
```

步骤 2:配置文件中配置多参数注入

在 applicationContext.xml 中配置注入

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>
    <bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"/>
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl">
        <constructor-arg name="bookDao" ref="bookDao"/>
        <constructor-arg name="userDao" ref="userDao"/>
    </bean>
</beans>
```

**说明:**这两个`<contructor-arg>`的配置顺序可以任意

##### 步骤 3:运行程序

运行 AppForDIConstructor 类，查看结果，说明 userDao 已经成功注入。

![1629802697318](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151020958.png)

#### 5.2.4 构造器注入多个简单数据类型

> 需求:在 BookDaoImpl 中，使用构造函数注入 databaseName 和 connectionNum 两个参数。
>
> 参考引用数据类型的注入，我们可以推出具体的步骤为:
>
> 1.提供一个包含这两个参数的构造方法
>
> 2.在 applicationContext.xml 中进行注入配置

##### 步骤 1:添加多个简单属性并提供构造方法

修改 BookDaoImpl 类，添加构造方法

```java
public class BookDaoImpl implements BookDao {
    private String databaseName;
    private int connectionNum;

    public BookDaoImpl(String databaseName, int connectionNum) {
        this.databaseName = databaseName;
        this.connectionNum = connectionNum;
    }

    public void save() {
        System.out.println("book dao save ..."+databaseName+","+connectionNum);
    }
}
```

##### 步骤 2:配置完成多个属性构造器注入

在 applicationContext.xml 中进行注入配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl">
        <constructor-arg name="databaseName" value="mysql"/>
        <constructor-arg name="connectionNum" value="666"/>
    </bean>
    <bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"/>
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl">
        <constructor-arg name="bookDao" ref="bookDao"/>
        <constructor-arg name="userDao" ref="userDao"/>
    </bean>
</beans>
```

**说明:**这两个`<contructor-arg>`的配置顺序可以任意

##### 步骤 3:运行程序

运行 AppForDIConstructor 类，查看结果

![1629803111769](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151020959.png)

上面已经完成了构造函数注入的基本使用，但是会存在一些问题:

![1629803529598](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151020960.png)

- 当构造函数中方法的参数名发生变化后，配置文件中的 name 属性也需要跟着变
- 这两块存在紧耦合，具体该如何解决?

在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，大家都以了解为主。

方式一:删除 name 属性，添加 type 属性，按照类型注入

```xml
<bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl">
    <constructor-arg type="int" value="10"/>
    <constructor-arg type="java.lang.String" value="mysql"/>
</bean>
```

- 这种方式可以解决构造函数形参名发生变化带来的耦合问题
- 但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了

方式二:删除 type 属性，添加 index 属性，按照索引下标注入，下标从 0 开始

```xml
<bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl">
    <constructor-arg index="1" value="100"/>
    <constructor-arg index="0" value="mysql"/>
</bean>
```

- 这种方式可以解决参数类型重复问题
- 但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题

介绍完两种参数的注入方式，具体我们该如何选择呢?

1. 强制依赖使用构造器进行，使用 setter 注入有概率不进行注入导致 null 对象出现
   - 强制依赖指对象在创建的过程中必须要注入指定的参数
2. 可选依赖使用 setter 注入进行，灵活性强
   - 可选依赖指对象在创建过程中注入的参数可有可无
3. Spring 框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨
4. 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用 setter 注入完成可选依赖的注入
5. 实际开发过程中还要根据实际情况分析，如果受控对象没有提供 setter 方法就必须使用构造器注入
6. **==自己开发的模块推荐使用 setter 注入==**

这节中主要讲解的是 Spring 的依赖注入的实现方式:

- setter 注入

  - 简单数据类型

    ```xml
    <bean ...>
    	<property name="" value=""/>
    </bean>
    ```

  - 引用数据类型

    ```xml
    <bean ...>
    	<property name="" ref=""/>
    </bean>
    ```

- 构造器注入

  - 简单数据类型

    ```xml
    <bean ...>
    	<constructor-arg name="" index="" type="" value=""/>
    </bean>
    ```

  - 引用数据类型

    ```xml
    <bean ...>
    	<constructor-arg name="" index="" type="" ref=""/>
    </bean>
    ```

- 依赖注入的方式选择上

  - 建议使用 setter 注入
  - 第三方技术根据情况选择

### 5.3 自动配置

前面花了大量的时间把 Spring 的注入去学习了下，总结起来就一个字==麻烦==。

问:麻烦在哪?

答:配置文件的编写配置上。

问:有更简单方式么?

答:有，自动配置

什么是自动配置以及如何实现自动配置，就是接下来要学习的内容：

#### 5.3.1 什么是依赖自动装配?

- IoC 容器根据 bean 所依赖的资源在容器中自动查找并注入到 bean 中的过程称为自动装配

#### 5.3.2 自动装配方式有哪些?

- ==按类型（常用）==
- 按名称
- 按构造方法
- 不启用自动装配

#### 5.3.3 准备下案例环境

- 创建一个 Maven 项目
- pom.xml 添加依赖
- resources 下添加 spring 的配置文件

这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:

![1629805387647](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151020961.png)

(1)项目中添加 BookDao、BookDaoImpl、BookService 和 BookServiceImpl 类

```java
public interface BookDao {
    public void save();
}

public class BookDaoImpl implements BookDao {

    private String databaseName;
    private int connectionNum;

    public void save() {
        System.out.println("book dao save ...");
    }
}
public interface BookService {
    public void save();
}

public class BookServiceImpl implements BookService{
    private BookDao bookDao;

    public void setBookDao(BookDao bookDao) {
        this.bookDao = bookDao;
    }

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}
```

(2)resources 下提供 spring 的配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl">
        <property name="bookDao" ref="bookDao"/>
    </bean>
</beans>
```

(3)编写 AppForAutoware 运行类，加载 Spring 的 IOC 容器，并从中获取对应的 bean 对象

```java
public class AppForAutoware {
    public static void main( String[] args ) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        BookService bookService = (BookService) ctx.getBean("bookService");
        bookService.save();
    }
}
```

#### 5.3.4 完成自动装配的配置

接下来，在上面这个环境中来完成`自动装配`的学习:

自动装配只需要修改 applicationContext.xml 配置文件即可:

(1)将`<property>`标签删除

(2)在`<bean>`标签中添加 autowire 属性

首先来实现按照类型注入的配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean class="com.itheima.dao.impl.BookDaoImpl"/>
    <!--autowire属性：开启自动装配，通常使用按类型装配-->
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl" autowire="byType"/>

</beans>
```

==注意事项:==

- 需要注入属性的类中对应属性的 setter 方法不能省略
- 被注入的对象必须要被 Spring 的 IOC 容器管理
- 按照类型在 Spring 的 IOC 容器中如果找到多个对象，会报`NoUniqueBeanDefinitionException`

一个类型在 IOC 中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式为:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean class="com.itheima.dao.impl.BookDaoImpl"/>
    <!--autowire属性：开启自动装配，通常使用按类型装配-->
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl" autowire="byName"/>

</beans>
```

==注意事项:==

- 按照名称注入中的名称指的是什么?

  ![1629806856156](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151020962.png)

  - bookDao 是 private 修饰的，外部类无法直接方法
  - 外部类只能通过属性的 set 方法进行访问
  - 对外部类来说，setBookDao 方法名，去掉 set 后首字母小写是其属性名
    - 为什么是去掉 set 首字母小写?
    - 这个规则是 set 方法生成的默认规则，set 方法的生成是把属性名首字母大写前面加 set 形成的方法名
  - 所以按照名称注入，其实是和对应的 set 方法有关，但是如果按照标准起名称，属性名和 set 对应的名是一致的

- 如果按照名称去找对应的 bean 对象，找不到则注入 Null

- 当某一个类型在 IOC 容器中有多个对象，按照名称注入只找其指定名称对应的 bean 对象，不会报错

两种方式介绍完后，以后用的更多的是==按照类型==注入。

最后对于依赖注入，需要注意一些其他的配置特征:

1. 自动装配用于引用类型依赖注入，不能对简单类型进行操作
2. 使用按类型装配时（byType）必须保障容器中相同类型的 bean 唯一，推荐使用
3. 使用按名称装配时（byName）必须保障容器中具有指定名称的 bean，因变量名与配置耦合，不推荐使用
4. 自动装配优先级低于 setter 注入与构造器注入，同时出现时自动装配配置失效

### 5.4 集合注入

前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型==集合==，集合中既可以装简单数据类型也可以装引用数据类型，对于集合，在 Spring 中该如何注入呢?

先来回顾下，常见的集合类型有哪些?

- 数组
- List
- Set
- Map
- Properties

针对不同的集合类型，该如何实现注入呢?

#### 5.4.1 环境准备

- 创建一个 Maven 项目
- pom.xml 添加依赖
- resources 下添加 spring 的配置文件 applicationContext.xml

这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:

![1629807579330](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151020963.png)

(1)项目中添加添加 BookDao、BookDaoImpl 类

```java
public interface BookDao {
    public void save();
}

public class BookDaoImpl implements BookDao {

public class BookDaoImpl implements BookDao {

    private int[] array;

    private List<String> list;

    private Set<String> set;

    private Map<String,String> map;

    private Properties properties;

     public void save() {
        System.out.println("book dao save ...");

        System.out.println("遍历数组:" + Arrays.toString(array));

        System.out.println("遍历List" + list);

        System.out.println("遍历Set" + set);

        System.out.println("遍历Map" + map);

        System.out.println("遍历Properties" + properties);
    }
	//setter....方法省略，自己使用工具生成
}
```

(2)resources 下提供 spring 的配置文件，applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>
</beans>
```

(3)编写 AppForDICollection 运行类，加载 Spring 的 IOC 容器，并从中获取对应的 bean 对象

```java
public class AppForDICollection {
    public static void main( String[] args ) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        BookDao bookDao = (BookDao) ctx.getBean("bookDao");
        bookDao.save();
    }
}
```

接下来，在上面这个环境中来完成`集合注入`的学习:

下面的所以配置方式，都是在 bookDao 的 bean 标签中使用<property>进行注入

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl">

    </bean>
</beans>
```

#### 5.4.2 注入数组类型数据

```xml
<property name="array">
    <array>
        <value>100</value>
        <value>200</value>
        <value>300</value>
    </array>
</property>
```

#### 5.4.3 注入 List 类型数据

```xml
<property name="list">
    <list>
        <value>itcast</value>
        <value>itheima</value>
        <value>boxuegu</value>
        <value>chuanzhihui</value>
    </list>
</property>
```

#### 5.4.4 注入 Set 类型数据

```xml
<property name="set">
    <set>
        <value>itcast</value>
        <value>itheima</value>
        <value>boxuegu</value>
        <value>boxuegu</value>
    </set>
</property>
```

#### 5.4.5 注入 Map 类型数据

```xml
<property name="map">
    <map>
        <entry key="country" value="china"/>
        <entry key="province" value="henan"/>
        <entry key="city" value="kaifeng"/>
    </map>
</property>
```

#### 5.4.6 注入 Properties 类型数据

```xml
<property name="properties">
    <props>
        <prop key="country">china</prop>
        <prop key="province">henan</prop>
        <prop key="city">kaifeng</prop>
    </props>
</property>
```

配置完成后，运行下看结果:

![1629808046783](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151020964.png)

**说明：**

- property 标签表示 setter 方式注入，构造方式注入 constructor-arg 标签内部也可以写`<array>`、`<list>`、`<set>`、`<map>`、`<props>`标签
- List 的底层也是通过数组实现的，所以`<list>`和`<array>`标签是可以混用
- 集合中要添加引用类型，只需要把`<value>`标签改成`<ref>`标签，这种方式用的比较少
