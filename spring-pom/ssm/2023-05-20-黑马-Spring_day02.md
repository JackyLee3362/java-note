## Spring_day02

**今日目标**

> - 掌握 IOC/DI 配置管理第三方 bean
> - 掌握 IOC/DI 的注解开发
> - 掌握 IOC/DI 注解管理第三方 bean
> - 完成 Spring 与 Mybatis 及 Junit 的整合开发

## 1，IOC/DI 配置管理第三方 bean

前面所讲的知识点都是基于我们自己写的类，现在如果有需求让我们去管理第三方 jar 包中的类，该如何管理?

### 1.1 案例:数据源对象管理

在这一节中，我们将通过一个案例来学习下对于第三方 bean 该如何进行配置管理。

以后我们会用到很多第三方的 bean,本次案例将使用咱们前面提到过的数据源`Druid(德鲁伊)`和`C3P0`来配置学习下。

#### 1.1.3 实现 Druid 管理

带着这两个问题，把下面的案例实现下:

##### 步骤 1:导入`druid`的依赖

pom.xml 中添加依赖

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
</dependency>
```

##### 步骤 2:配置第三方 bean

在 applicationContext.xml 配置文件中添加`DruidDataSource`的配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd">
	<!--管理DruidDataSource对象-->
    <bean class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/spring_db"/>
        <property name="username" value="root"/>
        <property name="password" value="root"/>
    </bean>
</beans>
```

**说明:**

- driverClassName:数据库驱动
- url:数据库连接地址
- username:数据库连接用户名
- password:数据库连接密码
- 数据库连接的四要素要和自己使用的数据库信息一致。

##### 步骤 3:从 IOC 容器中获取对应的 bean 对象

```java
public class App {
    public static void main(String[] args) {
       ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
       DataSource dataSource = (DataSource) ctx.getBean("dataSource");
       System.out.println(dataSource);
    }
}
```

##### 步骤 4:运行程序

打印如下结果: 说明第三方 bean 对象已经被 spring 的 IOC 容器进行管理

![1629887733081](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151022160.png)

做完案例后，我们可以将刚才思考的两个问题答案说下:

- 第三方的类指的是什么?

  ```
  DruidDataSource
  ```

- 如何注入数据库连接四要素?

  ```
  setter注入
  ```

#### 1.1.4 实现 C3P0 管理

完成了 DruidDataSource 的管理，接下来我们再来加深下练习，这次我们来管理`C3P0`数据源，具体的实现步骤是什么呢?

> 需求:使用 Spring 的 IOC 容器来管理 C3P0 连接池对象
>
> 实现方案和上面基本一致，重点要关注管理的是哪个 bean 对象`?

##### 步骤 1:导入`C3P0`的依赖

pom.xml 中添加依赖

```xml
<dependency>
    <groupId>c3p0</groupId>
    <artifactId>c3p0</artifactId>
    <version>0.9.1.2</version>
</dependency>
```

**对于新的技术，不知道具体的坐标该如何查找?**

- 直接百度搜索

- 从 mvn 的仓库`https://mvnrepository.com/`中进行搜索

  ![1629888540286](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151022161.png)

##### 步骤 2:配置第三方 bean

在 applicationContext.xml 配置文件中添加配置

```xml
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="com.mysql.jdbc.Driver"/>
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring_db"/>
    <property name="user" value="root"/>
    <property name="password" value="root"/>
    <property name="maxPoolSize" value="1000"/>
</bean>
```

**==注意:==**

- ComboPooledDataSource 的属性是通过 setter 方式进行注入
- 想注入属性就需要在 ComboPooledDataSource 类或其上层类中有提供属性对应的 setter 方法
- C3P0 的四个属性和 Druid 的四个属性是不一样的

##### 步骤 3:运行程序

程序会报错，错误如下

![1629889170229](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151022162.png)

报的错为==ClassNotFoundException==,翻译出来是`类没有发现的异常`，具体的类为`com.mysql.jdbc.Driver`。错误的原因是缺少 mysql 的驱动包。

分析出错误的原因，具体的解决方案就比较简单，只需要在 pom.xml 把驱动包引入即可。

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.47</version>
</dependency>
```

添加完 mysql 的驱动包以后，再次运行 App,就可以打印出结果:

![1629903845404](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151022163.png)

**注意：**

- 数据连接池在配置属性的时候，除了可以注入数据库连接四要素外还可以配置很多其他的属性，具体都有哪些属性用到的时候再去查，一般配置基础的四个，其他都有自己的默认值
- Druid 和 C3P0 在没有导入 mysql 驱动包的前提下，一个没报错一个报错，说明 Druid 在初始化的时候没有去加载驱动，而 C3P0 刚好相反
- Druid 程序运行虽然没有报错，但是当调用 DruidDataSource 的 getConnection()方法获取连接的时候，也会报找不到驱动类的错误

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:context="http://www.springframework.org/schema/context"
         xsi:schemaLocation="
              http://www.springframework.org/schema/beans
              http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/context
              http://www.springframework.org/schema/context/spring-context.xsd">

      <context:property-placeholder location="jdbc.properties" system-properties-mode="NEVER"/>
  </beans>
  ```

  system-properties-mode:设置为 NEVER,表示不加载系统属性，就可以解决上述问题。

  当然还有一个解决方案就是避免使用`username`作为属性的`key`。

- 问题二:当有多个 properties 配置文件需要被加载，该如何配置?

  1.调整下配置文件的内容，在 resources 下添加`jdbc.properties`,`jdbc2.properties`,内容如下:

  jdbc.properties

  ```ini
  jdbc.driver=com.mysql.jdbc.Driver
  jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db
  jdbc.username=root
  jdbc.password=root
  ```

  jdbc2.properties

  ```ini
  username=root666
  ```

  2.修改 applicationContext.xml

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:context="http://www.springframework.org/schema/context"
         xsi:schemaLocation="
              http://www.springframework.org/schema/beans
              http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/context
              http://www.springframework.org/schema/context/spring-context.xsd">
      <!--方式一 -->
      <context:property-placeholder location="jdbc.properties,jdbc2.properties" system-properties-mode="NEVER"/>
      <!--方式二-->
      <context:property-placeholder location="*.properties" system-properties-mode="NEVER"/>
      <!--方式三 -->
      <context:property-placeholder location="classpath:*.properties" system-properties-mode="NEVER"/>
      <!--方式四-->
      <context:property-placeholder location="classpath*:*.properties" system-properties-mode="NEVER"/>
  </beans>
  ```

  **说明:**

  - 方式一:可以实现，如果配置文件多的话，每个都需要配置
  - 方式二:`*.properties`代表所有以 properties 结尾的文件都会被加载，可以解决方式一的问题，但是不标准
  - 方式三:标准的写法，`classpath:`代表的是从根路径下开始查找，但是只能查询当前项目的根路径
  - 方式四:不仅可以加载当前项目还可以加载当前项目所依赖的所有项目的根路径下的 properties 配置文件

#### 1.2.3 加载 properties 文件小结

本节主要讲解的是 properties 配置文件的加载，需要掌握的内容有:

- 如何开启`context`命名空间

  ![1629980280952](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151022166.png)

- 如何加载 properties 配置文件

  ```xml
  <context:property-placeholder location="" system-properties-mode="NEVER"/>
  ```

- 如何在 applicationContext.xml 引入 properties 配置文件中的值

  ```
  ${key}
  ```

## 3，IOC/DI 注解开发

### 3.4 注解开发依赖注入

Spring 为了使用注解简化开发，并没有提供`构造函数注入`、`setter注入`对应的注解，只提供了自动装配的注解实现。

**注意:**

- @Autowired 可以写在属性上，也可也写在 setter 方法上，最简单的处理方式是`写在属性上并将setter方法删除掉`
- 为什么 setter 方法可以删除呢?
  - 自动装配基于反射设计创建对象并通过暴力反射为私有属性进行设值
  - 普通反射只能获取 public 修饰的内容
  - 暴力反射除了获取 public 修饰的内容还可以获取 private 修改的内容
  - 所以此处无需提供 setter 方法

(2)@Autowired 是按照类型注入，那么对应 BookDao 接口如果有多个实现类，比如添加 BookDaoImpl2

```java
@Repository
public class BookDaoImpl2 implements BookDao {
    public void save() {
        System.out.println("book dao save ...2");
    }
}
```

这个时候再次运行 App，就会报错

![1630034272959](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151022187.png)

此时，按照类型注入就无法区分到底注入哪个对象，解决方案:`按照名称注入`

- 先给两个 Dao 类分别起个名称

  ```java
  @Repository("bookDao")
  public class BookDaoImpl implements BookDao {
      public void save() {
          System.out.println("book dao save ..." );
      }
  }
  @Repository("bookDao2")
  public class BookDaoImpl2 implements BookDao {
      public void save() {
          System.out.println("book dao save ...2" );
      }
  }
  ```

  此时就可以注入成功，但是得思考个问题:

  - @Autowired 是按照类型注入的，给 BookDao 的两个实现起了名称，它还是有两个 bean 对象，为什么不报错?

  - @Autowired 默认按照类型自动装配，如果 IOC 容器中同类的 Bean 找到多个，就按照变量名和 Bean 的名称匹配。因为变量名叫`bookDao`而容器中也有一个`booDao`，所以可以成功注入。

  - 分析下面这种情况是否能完成注入呢?

    ![1630036236150](https://assets-1302294329.cos.ap-shanghai.myqcloud.com/2025/md/202505151022188.png)

  - 不行，因为按照类型会找到多个 bean 对象，此时会按照`bookDao`名称去找，因为 IOC 容器只有名称叫`bookDao1`和`bookDao2`,所以找不到，会报`NoUniqueBeanDefinitionException`

#### 3.4.3 注解实现按照名称注入

当根据类型在容器中找到多个 bean,注入参数的属性名又和容器中 bean 的名称不一致，这个时候该如何解决，就需要使用到`@Qualifier`来指定注入哪个名称的 bean 对象。

```java
@Service
public class BookServiceImpl implements BookService {
    @Autowired
    @Qualifier("bookDao1")
    private BookDao bookDao;

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}
```

@Qualifier 注解后的值就是需要注入的 bean 的名称。

==注意:@Qualifier 不能独立使用，必须和@Autowired 一起使用==

#### 3.4.4 简单数据类型注入

引用类型看完，简单类型注入就比较容易懂了。
简单类型注入的是基本数据类型或者字符串类型，下面在`BookDaoImpl`类中添加一个`name`属性，用其进行简单类型注入

```java
@Repository("bookDao")
public class BookDaoImpl implements BookDao {
    private String name;
    public void save() {
        System.out.println("book dao save ..." + name);
    }
}
```

介绍完后，会有一种感觉就是这个注解好像没什么用，跟直接赋值是一个效果，还没有直接赋值简单，所以这个注解存在的意义是什么?

### 4.2 注解开发管理第三方 bean

### 4.3 引入外部配置类

#### 4.3.1 使用包扫描引入

##### 步骤 1:在 Spring 的配置类上添加包扫描

##### 步骤 2:在 JdbcConfig 上添加配置注解

#### 4.3.2 使用`@Import`引入

这种方案可以不用加`@Configuration`注解，但是必须在 Spring 配置类上使用`@Import`注解手动引入需要加载的配置类

##### 步骤 1:去除 JdbcConfig 类上的注解

```java
public class JdbcConfig {
	@Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/spring_db");
        ds.setUsername("root");
        ds.setPassword("root");
        return ds;
    }
}
```

##### 步骤 2:在 Spring 配置类中引入

```java
@Configuration
//@ComponentScan("com.itheima.config")
@Import({JdbcConfig.class})
public class SpringConfig {

}
```

**注意:**

- 扫描注解可以移除

- @Import 参数需要的是一个数组，可以引入多个配置类。

- @Import 注解在配置类中只能写一次，下面的方式是==不允许的==

  ```java
  @Configuration
  //@ComponentScan("com.itheima.config")
  @Import(JdbcConfig.class)
  @Import(Xxx.class)
  public class SpringConfig {

  }
  ```

##### 步骤 3:运行程序

依然能获取到 bean 对象并打印控制台

### 知识点 1：@Bean

| 名称 | @Bean                                     |
| ---- | ----------------------------------------- |
| 类型 | 方法注解                                  |
| 位置 | 方法定义上方                              |
| 作用 | 设置该方法的返回值作为 spring 管理的 bean |
| 属性 | value（默认）：定义 bean 的 id            |

### 知识点 2：@Import

| 名称 | @Import                                                                                    |
| ---- | ------------------------------------------------------------------------------------------ |
| 类型 | 类注解                                                                                     |
| 位置 | 类定义上方                                                                                 |
| 作用 | 导入配置类                                                                                 |
| 属性 | value（默认）：定义导入的配置类类名，<br/>当配置类有多个时使用数组格式一次性导入多个配置类 |

##### 4.4.1.1 需求分析

对于下面代码关于数据库的四要素不应该写死在代码中，应该是从 properties 配置文件中读取。如何来优化下面的代码?

```java
public class JdbcConfig {
	@Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/spring_db");
        ds.setUsername("root");
        ds.setPassword("root");
        return ds;
    }
}
```

##### 4.4.1.2 注入简单数据类型步骤

###### 步骤 1:类中提供四个属性

```java
public class JdbcConfig {
    private String driver;
    private String url;
    private String userName;
    private String password;
	@Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/spring_db");
        ds.setUsername("root");
        ds.setPassword("root");
        return ds;
    }
}
```

###### 扩展

现在的数据库连接四要素还是写在代码中，需要做的是将这些内容提

取到 jdbc.properties 配置文件，大家思考下该如何实现?

> 1.resources 目录下添加 jdbc.properties
>
> 2.配置文件中提供四个键值对分别是数据库的四要素
>
> 3.使用@PropertySource 加载 jdbc.properties 配置文件
>
> 4.修改@Value 注解属性的值，将其修改为`${key}`，key 就是键值对中的键的值

具体的实现就交由大家自行实现下。

#### 4.4.2 引用数据类型

##### 4.4.2.1 需求分析

假设在构建 DataSource 对象的时候，需要用到 BookDao 对象，该如何把 BookDao 对象注入进方法内让其使用呢?

```java
public class JdbcConfig {
	@Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/spring_db");
        ds.setUsername("root");
        ds.setPassword("root");
        return ds;
    }
}
```

##### 4.4.2.2 注入引用数据类型步骤

###### 步骤 1:在 SpringConfig 中扫描 BookDao

扫描的目的是让 Spring 能管理到 BookDao,也就是说要让 IOC 容器中有一个 bookDao 对象

```java
@Configuration
@ComponentScan("com.itheima.dao")
@Import({JdbcConfig.class})
public class SpringConfig {
}
```

###### 步骤 2:在 JdbcConfig 类的方法上添加参数

```java
@Bean
public DataSource dataSource(BookDao bookDao){
    System.out.println(bookDao);
    DruidDataSource ds = new DruidDataSource();
    ds.setDriverClassName(driver);
    ds.setUrl(url);
    ds.setUsername(userName);
    ds.setPassword(password);
    return ds;
}
```

==引用类型注入只需要为 bean 定义方法设置形参即可，容器会根据类型自动装配对象。==
